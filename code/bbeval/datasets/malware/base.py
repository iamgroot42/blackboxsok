import os
import numpy as np
import torch as ch
from secml.array import CArray
from ember.features import PEFeatureExtractor
from torch.utils.data import DataLoader

from bbeval.config import DatasetConfig, TrainConfig
from bbeval.datasets.base import CustomDatasetWrapper


class MalwareDatasetWrapper(CustomDatasetWrapper):
    def __init__(self, data_config: DatasetConfig, num_classes: int):
        """
            self.ds_train and self.ds_test should be set to
            datasets to be used to train and evaluate.
        """
        super().__init__(data_config, num_classes)
        self.processed = False
        # TODO: Figure out what the collate_fn should be
        def collate_fn(batch):
            p, fb, fr = [], [], []
            for b in batch:
                p.append(b.path)
                fb.append(b.bytes)
                fr.append(b.feature)
            batch_wrapper = MalwareDatumWrapper(p, fb, fr)
            return batch_wrapper

        self.collate_fn = collate_fn


class MalwareDatumWrapper:
    def __init__(self, path, file_byte=None, feature_rep=None):
        self.filepath = path
        self.file_bytes = file_byte
        self.feature_rep = feature_rep
        self.is_list = (type(self.file_bytes) == list)
        self.objs = None

        if self.is_list:
            if self.file_bytes is not None:
                assert len(self.file_bytes) == len(self.filepath), "file_bytes and filepath must be same length"
            if self.feature_rep is not None:
                assert len(self.feature_rep) == len(self.filepath), "feature_rep and filepath must be same length"

            self.objs = []
            for i, p in enumerate(self.filepath):
                fb = None if file_byte is None else file_byte[i]
                fr = None if feature_rep is None else feature_rep[i]
                self.objs.append(MalwareDatumWrapper(p, fb, fr))

    @property
    def path(self):
        return self.filepath
    
    def __len__(self):
        if not self.is_list:
            raise ValueError("This MalwareDatumWrapper object is not a list")
        return len(self.objs)

    @property
    def bytes(self):
        if self.is_list:
            # If batch wrapper
            return CArray([obj.bytes for obj in self.objs])
        else:
            # Caching
            if self.file_bytes is None:
                with open(self.filepath, 'rb') as f:
                    self.file_bytes = f.read()
            return self.file_bytes
    
    @bytes.setter
    def bytes(self, file_bytes):
        if self.is_list:
            # If batch wrapper
            assert len(file_bytes) == len(self.objs), "feature_rep and filepath must be same length"
            for i, obj in enumerate(self.objs):
                obj.bytes = file_bytes[i]
        else:
            self.file_bytes = file_bytes
    
    def __getitem__(self, i):
        if not self.is_list:
            raise IndexError("This MalwareDatumWrapper object is not a list")
        return self.objs[i]

    @property
    def feature(self):
        if self.is_list:
            # If batch wrapper
            feature_reps = [obj.feature for obj in self.objs]
            if None in feature_reps:
                return feature_reps
            return CArray(feature_reps)
        # If individual item
        return self.feature_rep
    
    @feature.setter
    def feature(self, feature_rep):
        if self.is_list:
            # If batch wrapper
            assert len(feature_rep) == len(self.objs), "feature_rep and filepath must be same length"
            for i, obj in enumerate(self.objs):
                obj.feature = feature_rep[i]
        else:
            self.feature_rep = feature_rep


class MalwareFilesDataset(ch.utils.data.Dataset):
    def __init__(self, file_list):
        self.file_list = file_list
        self.datums = [MalwareDatumWrapper(fp) for fp in self.file_list]
    
    def __getitem__(self, index):
        return self.datums[index]
    
    def __len__(self):
        return len(self.datums)


def process_with_lief(X, want_json: bool = False):
    feature_version = 2
    extractor = PEFeatureExtractor(feature_version)
    if want_json:
        return extractor.raw_features(X)
    else:
        return extractor.feature_vector(X)
