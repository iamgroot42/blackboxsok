import os
import magic
from secml.array import CArray

from secml_malware.attack.whitebox.c_header_evasion import CHeaderEvasion
from secml_malware.attack.whitebox import CKreukEvasion
from dataclasses import asdict
from bbeval.attacker.utils import get_attack_wrapper

from bbeval.datasets.malware.bodmas_dataset import BODMASWrapper

from bbeval.config import DatasetConfig, MalwareModelConfig, MalwareAttackerConfig, ExperimentConfig
from bbeval.models.pytorch.malware import SecmlMalConv
from bbeval.attacker.transfer_methods.kreuk_evasion import Padding


def single_attack(target_model, aux_models, x_orig, x_sample_adv, y_label, y_target,
                  attacker_config: MalwareAttackerConfig,
                  experiment_config: ExperimentConfig):
    attacker = get_attack_wrapper( target_model, aux_models, attacker_config, experiment_config)
    x_sample_adv, queries_used = attacker.attack(x_orig, x_sample_adv, y_label, y_target)
    return (x_sample_adv, queries_used), attacker

experiment_config = ExperimentConfig.load("configs/malware/malware_demo.json", drop_extra_fields=False)
model_config = MalwareModelConfig(name="malconv", dataset="ember")
data_config = DatasetConfig(name="bodmas", type="malware")
net = SecmlMalConv(model_config)
attacker = Padding(model=net,
                   aux_models=None,
                   config=experiment_config.attack_configs[0],
                   experiment_config=experiment_config)

ds = BODMASWrapper(experiment_config.dataset_config)
_, _, test_loader = ds.get_loaders(batch_size=4)

batch = next(iter(test_loader))
x_features = net.pre_process(batch)
X = batch
confidence = net.predict_proba(x_features)

attacker_config_1: MalwareAttackerConfig = experiment_config.first_attack_config()
(x_sample_adv, queries_used_1), attacker_1 = single_attack(net,
                  aux_models={},
                  x_orig=X,
                  x_sample_adv=X,
                  y_label=confidence,
                  y_target=None,
                  attacker_config=attacker_config_1,
                  experiment_config=experiment_config)

# CHeaderEvasion
# partial_dos = CHeaderEvasion(net, random_init=False, iterations=50, optimize_all_dos=False, threshold=0.5)
# for sample, label in zip(X, y):
#     y_pred, adv_score, adv_ds, f_obj = partial_dos.run(CArray(sample.feature), CArray(label[1]))
#     print(partial_dos.confidences_)
#     print(f_obj)

#     adv_x = adv_ds.X[0,:]
#     real_adv_x = partial_dos.create_real_sample_from_adv(sample.path, adv_x)
#     print(len(real_adv_x))
#     real_x = End2EndModel.bytes_to_numpy(real_adv_x, net.get_input_max_length(), 256, False)
#     _, confidence = net.predict(CArray(real_x), True)
#     print(confidence[0,1].item())

# CKreukEvasion
fgsm = CKreukEvasion(net, how_many_padding_bytes=2048, epsilon=1.0, iterations=5)
for i, (sample, label) in enumerate(zip(X, y)):
    y_pred, adv_score, adv_ds, f_obj = fgsm.run(CArray(sample.feature), CArray(label[1]))
    print(fgsm.confidences_)
    print(f_obj)
    print(adv_ds)
    # real_adv_x = fgsm.create_real_sample_from_adv(file_names[i], adv_ds.X[i, :])
    real_adv_x = fgsm.create_real_sample_from_adv(sample.path, adv_ds.X)
    print('Original length: ', len(sample.bytes))
    print('Adversarial sample length: ', len(real_adv_x))
